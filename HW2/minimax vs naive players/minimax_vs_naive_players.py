# -*- coding: utf-8 -*-
"""Minimax vs Naive Players.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o4nYlgC5RSzMCVVzN6heCuMqzh4EGZ8N

Consider the given 8*8 board game. There are two players in this game and they try to block each other and limit their valid moves by making walls. Their moves are limited to the 8 cells (or less when they are around the edges) beside them and the walls will start to appear only when a player steps into a random generated yellow cell and the wall will continue to be built until the player reaches the next yellow cell. The players start the game at (0,0) and (7,7) and they keep playing untill one of them loses. There are multiple ways for a player to win the match:
- If a player steps into a wall or out of the board, the player loses the match and "invalid move" massege will appear on terminal.
- If the players reach the maximum moves the game finishes and the winner would be chosen based on the maximum valid move they have left plus the number of walls they have made and "No more moves" massege will appear on terminal.
- If the getMove() function does not return any value after 2 seconds, the player loses the match and "Time limit exceeded" massege will appear on terminal.
<img src="Images/Q3.png" style="float: center; margin-left: 250px; margin-top: 50px; width:500px;height:400px;"/>

In this question, the codes for starting the game were provided for you in Helper-codes folder. You are expected to implement the MinimaxPlayer class (which inherit the Player class) with alpha-beta pruning. (25 points)

## Libraries
"""

#!pip install tk
#!pip install matplotlib
import numpy as np
import random
from Helper_codes.graphics import *
from Helper_codes.question3 import Cell
from Helper_codes.question3 import IntPair
from Helper_codes.question3 import Player
from Helper_codes.question3 import NaivePlayer
from Helper_codes.question3 import Board
from Helper_codes.question3 import Game
import time
import matplotlib.pyplot as plt

"""**The following implementations are suggestional and you may change them if you desire.
The move_ functions' purpose is to find out if a player, has a valid move on that direction.
the purpose of checkRow and CheckCole are to check if the player's x and y is still in the board.**

"""

#to do
class MinimaxPlayer(Player):
    
    def __init__(self, col, x, y, depth):
        super().__init__(col, x, y)
        self.depth = depth
        
    def checkCol(self, x):
        if x < 8:
            if x >= 0 :
                return True 
        return False
    
    def checkRow(self, y):
        if y < 8:
            if y >= 0 :
                return True 
        return False
    

    def moveU(self, x, y, board):
        if y + 1 < board.getSize():
            if board.getCell(x , y + 1).getColor() <= 0 :
                return True 
        return False
    

    def moveD(self, x, y, board):
        if y - 1 >= 0 :
            if board.getCell(x , y - 1).getColor() <= 0:
                return True 
        return False

    def moveR(self, x, y, board):
        if x + 1 < board.getSize():
            if board.getCell(x + 1, y).getColor() <= 0:
                return True
        return False
    
    def moveL(self, x, y, board):
        if x - 1 >= 0 :
            if board.getCell(x - 1, y).getColor() <= 0:
                return True
        return False

    def moveUR(self, x, y, board):
        if x + 1 < board.getSize():
            if y + 1 < board.getSize():
                if board.getCell(x + 1, y + 1).getColor() <= 0:
                    return True
        return False
    
    def moveUL(self, x, y, board):
        if x - 1 >= 0 :
            if y + 1 < board.getSize():
                if board.getCell(x - 1, y + 1).getColor() <= 0:
                    return True
        return False

    def moveDR(self, x, y, board):
        if x + 1 < board.getSize():
            if y - 1 >= 0 :
                if board.getCell(x + 1, y - 1).getColor() <= 0:
                    return True
        return False

    def moveDL(self, x, y, board):
        if x - 1 >= 0 :
            if y - 1 >= 0 :
                if board.getCell(x - 1, y - 1).getColor() <= 0:
                    return True
        return False

    def canMove(self, x, y, board):
        State1 = self.moveU(x, y, board)
        State2 = self.moveD(x, y, board)
        State3 = self.moveR(x, y, board)
        State4 = self.moveL(x, y, board)
        State5 = self.moveUR(x, y, board)
        State6 = self.moveUL(x, y, board)
        State7 = self.moveDR(x, y, board)
        State8 = self.moveDL(x, y, board)        
        Fina_state = State1 or State2 or State3 or State4 or State5 or State6 or State7 or State8
        return Fina_state

    def minValue(self, board, alpha, beta, depth, d):
        x = self.getX()
        y = self.getY()
        State1 = self.moveU(self.getX(), self.getY(), board)
        State2 = self.moveD(self.getX(), self.getY(), board)
        State3 = self.moveR(self.getX(), self.getY(), board)
        State4 = self.moveL(self.getX(), self.getY(), board)
        State5 = self.moveUR(self.getX(), self.getY(), board)
        State6 = self.moveUL(self.getX(), self.getY(), board)
        State7 = self.moveDR(self.getX(), self.getY(), board)
        State8 = self.moveDL(self.getX(), self.getY(), board)   
        states = [State1,State2,State3,State4,State5,State6,State7,State8]
        moves= [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]]
        v = float('inf')
        if d==0:
            v = board.getScore(3-self.getCol())
            return v
        for i in range(8):
            if states[i] == True:
                Newboard = Board(board)
                Newboard.move(IntPair(x+moves[i][0],y+moves[i][1]),self.getCol())
                v = min(v,self.maxValue(Newboard,alpha, beta, depth, d-1))
                if v < alpha:
                    return v
                beta = min(beta,v)
        return v

    def maxValue(self, board, alpha, beta, depth, d):
        x = self.getX()
        y = self.getY()
        State1 = self.moveU(self.getX(), self.getY(), board)
        State2 = self.moveD(self.getX(), self.getY(), board)
        State3 = self.moveR(self.getX(), self.getY(), board)
        State4 = self.moveL(self.getX(), self.getY(), board)
        State5 = self.moveUR(self.getX(), self.getY(), board)
        State6 = self.moveUL(self.getX(), self.getY(), board)
        State7 = self.moveDR(self.getX(), self.getY(), board)
        State8 = self.moveDL(self.getX(), self.getY(), board)  
        states = [State1,State2,State3,State4,State5,State6,State7,State8]
        moves= [[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,1],[1,-1],[-1,-1]]
        v = float('-inf')
        if d==0:
            v = board.getScore(self.getCol())
            return v
        best_road = moves[0]
        for i in range(8):
            if states[i] == True:
                Newboard = Board(board)
                Newboard.move(IntPair(x+moves[i][0],y+moves[i][1]),self.getCol())
                new_v = self.minValue(Newboard,alpha, beta, depth,d-1)
                if new_v > v:
                    v = new_v;
                    if d == depth:
                        best_road = moves[i]
                if new_v > beta:
                    if d == depth:
                        best_road = moves[i]
                        new_x =  self.getX() + best_road[0]
                        new_y =  self.getY() + best_road[1]
                        while not (self.checkRow(new_x) and self.checkRow(new_y)):
                            continue
                        return best_road 
                    return v
                alpha = max(alpha,v)
        if d == depth: 
            new_x =  self.getX() + best_road[0]
            new_y =  self.getY() + best_road[1]
            while not (self.checkRow(new_x) and self.checkRow(new_y)):
                continue
            return best_road
        return v
    
    def getMove(self, board):
        alpha = float('-inf')
        beta = float('inf')
        next = IntPair(-20, -20)

        if (board.getNumberOfMoves() == board.maxNumberOfMoves):
            return IntPair(-20, -20)
        
        if not (self.canMove(board.getPlayerX(self.getCol()), board.getPlayerY(self.getCol()), board)):
            return IntPair(-10, -10)
        
        if (self.getCol() == 1):
            road = self.maxValue(board, alpha, beta, self.depth, self.depth)
            x_next = self.getX() + road[0]
            y_next = self.getY() + road[1]
            board.move(IntPair(self.getX()+road[0],self.getY()+road[1]),self.getCol())
            return IntPair(x_next, y_next)
        
        else:
            road = self.maxValue(board, alpha, beta, self.depth, self.depth)
            x_next = self.getX() + road[0]
            y_next = self.getY() + road[1]
            board.move(IntPair(self.getX()+road[0],self.getY()+road[1]),self.getCol())
            return IntPair(x_next, y_next)

"""If you run the game once (numberOfMatches = 1) the game window will open and you would be able to observe the players behaviour and the reason why the winner has won, will appear on terminal.
If you run the game for more than one match (numberOfMatches > 1) the graphic window and the comments on terminal would not show up. This is for the time you finish implementing the MinimaxPlayer class and you want to verify the functionality of your code; also, for next part of the question, in which you should plot the scores for the first player.
"""

p1 = MinimaxPlayer(1, 0, 0 ,2)
p2 = NaivePlayer(2, 7, 7)
g = Game(p1, p2)
numberOfMatches = 1
score1, score2 = g.start(numberOfMatches)
print(score1/numberOfMatches)

"""In this section, you need to run the game code multiple times and each time with the same numberOfMatches (this should be a large number so your answer be more reliable) once for Naive player and once for Minimax. compare these two plots in terms of shape and the main elements of the distribution. (5 points)"""

p1 = NaivePlayer(2, 0, 0)
p2 = NaivePlayer(2, 7, 7)
g = Game(p1, p2)
numberOfMatches = 15
score1, score2 = g.start(numberOfMatches)
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
langs = ['player 1', 'player 2']
height = [score1, score2]
ax.bar(langs,height)
ax.set_title('Naive players')
plt.show()

p1 = MinimaxPlayer(1, 0, 0 ,2)
p2 = NaivePlayer(2, 7, 7)
g = Game(p1, p2)
numberOfMatches = 15
score1, score2 = g.start(numberOfMatches)

fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
langs = ['player 1', 'player 2']
height = [score1, score2]
ax.bar(langs,height)
ax.set_title('Minimax player vs Naive player')
plt.show()

"""In this section you should change the game settings for different depths and plot the number of wins in fix number of matches for these depths. Also, you should let two minimax players with diffrent depths play againts eachother and report your observation.(5 points)"""

h_list = [2,3,4,5,6]
result = np.zeros(len(h_list))
i = 0
for h in h_list:
    p1 = MinimaxPlayer(1, 0, 0 ,h)
    p2 = NaivePlayer(2, 7, 7)
    g = Game(p1, p2)
    numberOfMatches = 10
    score1, score2 = g.start(numberOfMatches)
    result[i] = score1
    i += 1
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
langs = ['h=2','h=3','h=4','h=5','h=6']
ax.bar(langs,result)
ax.set_title('Accuracy vs Depth')
plt.show()

p1 = MinimaxPlayer(1, 0, 0 ,2)
p2 = MinimaxPlayer(2, 7, 7, 2)
g = Game(p1, p2)
numberOfMatches = 1
score1, score2 = g.start(numberOfMatches)